% test_exploit_result.m 
% greedy result

% Q-learning

% episode_loops = 5e4; 

% large_neg_reward = -1e10;    % 一个很大的负reward

%%
dt = 0.1;
T = 150;
detaT = 3;
tvec = dt:dt:T;
Ntvec = length(tvec);
nT = length(tvec);

reference_speeds = [80/3.6 80/3.6];
initial_speed = 80/3.6;
initial_notch = 8;

Nt = 200+2;
Ne = 1;

X = zeros(Nt*2, Ne);     % 前面 Nt 个是速度，后面 Nt 个是位置
U = zeros(Nt, Ne);     % 前面 Nt 个是速度，后面 Nt 个是位置


X(1:Nt, :) = initial_speed;     % 初速度

carType = zeros(Nt, 1) == 1;  % 车辆类型，机车还是拖车
carType([1 end]) = true;        % 一头一尾两个机车

Nl = sum(carType);
Nw = sum(~carType);

MotorNotch = zeros(Nl, Ne) + round(rand(Nl, Ne)*20-10);     % 每个机车有独立的级位 

% TBCL_force

%% initialization

[Ad, Bd, TBcl, airTimeDelay, Abr, LenTrain, mTrainGroup, C0, Ca, KK, DD] = ...
    initialize_locomotive_char_V2(dt, carType, Ne);

% Bd = -Bd * 1e3;

LenTrains = LenTrain'*ones(1, Ne);


%% Load the infrastructure
% load('RampPositionList');  % 1.Format:start(m) end(m) gradient, 2.Range: [-10000m,100000m]
% % load('RampPoint'); % 1.Format:position(m) Height(m),  2.Range:[9000m,37972m]
% 
% rampList = RampPositionList(:, [1 3]);
% 
% rampList(:, 2) = -rampList(:, 2);

rampList = [-10000 0; 0 0.01; 1500 -0.01; 3000 0; 10000 0; 20000 0; 30000 0];


%% Air break

% air_timer = zeros(Nw, Ne);        % 空气制动计时器, 当前的
% air_timer_ = zeros(Nw, Ne);        % 空气制动计时器， 上一步的
% % AirBrkNotch = round(-rand(1, Ne)*2);       % 空气制动，-2, -1, 0;
% AirBrkNotch = round(-rand(1, Ne)*0);       % 空气制动，-2, -1, 0;
% AirBrkNotch_ = zeros(1, Ne);      % 空气制动之前一次控制量，1表示制动，0表示缓解
% 
% F_target = zeros(Nw, Ne);
% currentF = zeros(Nw, Ne);

%% Q matrix

nnum = 25;

S = 100/3.6*T;

Speed_Change_Point = 1500;

dl = 100;   % meter
dv = 1;     % km/h

s_vec = 0:dl:S+dl*1;
v_vec = 0:dv:100+dv*1;

ActionSet = get_ActionSet2();
n_act = size(ActionSet, 1);

% Q = zeros(length(s_vec), length(v_vec), nnum, nnum, n_act);
% Q(:, :, 1, :, [4 5 6]) = NaN;
% Q(:, :, :, 1, [2 5 8]) = NaN;
% Q(:, :, end, :, [7 8 9]) = NaN;
% Q(:, :, :, end, [2 5 8]+1) = NaN;

load Q_matrix_MC.mat

action = ones(1, Ne);
% action_ = action;

MotorNotch = MotorNotch + ActionSet(action, 1:2)';

v_tmp = ceil(X(1, :)*3.6)+1;
s_tmp = ceil(X(Nt+1, :)/dl)+1;

%% Recorder


X_Recorder = zeros(length(tvec), Ne);

F_l =  zeros(round(detaT/dt), Ne);
F_w =  zeros(round(detaT/dt), Ne);
F_c =  zeros(round(detaT/dt), Ne);
errV =  zeros(round(detaT/dt), Ne);


in_epi_number = round(T/detaT); %

reward_Record = zeros(in_epi_number, episode_loops, 4);

R_Recorder = zeros(episode_loops, Ne);

Repisode = zeros(episode_loops, 4);    % 每一步 episode 的回报

Rs_record4 = zeros(episode_loops, 4);    % 每一步的回报

Rs_record = zeros(in_epi_number, Ne);    % 每一步的回报
Qloc = zeros(in_epi_number, 9, Ne);    % 每一步的 state-action

X_location = zeros(Ntvec, 2);
F_locmotive = zeros(Ntvec, 2);
N_locmotive = zeros(Ntvec, 2);
F_coupler = zeros(Ntvec, 201);
Speed_locmotive = zeros(Ntvec, 2);
Ramp_locmotive = zeros(Ntvec, 2);


%% weight

% reward_weigh = [1/2.4e+14 1/6.64e+5 2e-6 1/1.63e3];
% reward_weigh = [1/4.5e3 0 0 1/1.63e3*1];
reward_weigh = [1/4e7 1/1e7 0 1/1e4*4];
% reward_weigh = [1/2e7 0 0 1/1e4*2];

%% 主循环


tic 
for etr = 1
    
    air_Notchs =  zeros(Ntvec, Ne)*NaN;
    loc_Notchs1 =  zeros(Ntvec, Ne)*NaN;
    loc_Notchs2 =  zeros(Ntvec, Ne)*NaN;
%     
    U_recorder = zeros(Nt, Ntvec)*NaN;
    L_recorder = zeros(2, Ntvec)*NaN;
    V_recorder = zeros(Nt, Ntvec)*NaN;
    RP_recorder = zeros(Nt, Ntvec)*NaN;
    
    %% initialization
    
    MotorNotch = zeros(Nl, Ne) + initial_notch;     % 每个机车有独立的级位
    
    epsilon  = 0;
    
    X = zeros(Nt*2, Ne);     % 前面 Nt 个是速度，后面 Nt 个是位置
%     X(1:Nt, :) = ones(Nt, 1)*((rand(1, Ne)*80+10)/3.6);     % 初速度
    X(1:Nt, :) = ones(Nt, Ne)*initial_speed;     % 初速度
    
    Rspeed = ones(Nt, Ne)*reference_speeds(1);
    
    v_tmp = ceil(X(1, :)*3.6)+1;
    s_tmp = ceil(X(Nt+1, :)/dl)+1;
    
    bo_tmp = rand(1, Ne) > epsilon;
    for i = 1:Ne 
        if bo_tmp(i)      % epsilon - greedy
            [~, action(i)] = max(Q(s_tmp(i), v_tmp(i), MotorNotch(1, i)+13, MotorNotch(2, i)+13, :));
        else
            action_tmp = find(~isnan(Q(s_tmp(i), v_tmp(i), MotorNotch(1, i)+13, MotorNotch(2, i)+13, :)));
            action(i) = action_tmp(ceil(rand*length(action_tmp)));
        end
    end
    
    MotorNotch_ = MotorNotch;   % 保存上一次
    MotorNotch = MotorNotch + ActionSet(action, 1:2)';
    
    count = 0;
    count_detaT = 0;
    R_tmp = zeros(4, Ne);
    Rsum = zeros(4, 1);
    Qloc = Qloc*0;
    for itr = 1:nT
        
        tmpBo = X(Nt+1, :) < Speed_Change_Point;
%         Rspeed(:, tmpBo) = reference_speeds(1);
        Rspeed(:, ~tmpBo) = reference_speeds(2);
        
        %% 计算四个力
        
        U = zeros(Nt, Ne);     % 前面 Nt 个是速度，后面 Nt 个是位置
        % ---------------------------------------------- 机车牵引力
        tmp_Fl = GetLocomotiveF_multi(X(carType, :)*3.6, MotorNotch, TBcl);
%         tmp_Fl = tmp_Fl.*(1+rand(size(tmp_Fl))*0.02-0.01);
        U(carType, :) = tmp_Fl * 1e3;
        
        % ---------------------------------------------- 空气制动力
        
        % ---------------------------------------------- 附加阻力阻力
        pTrains = LenTrains + X(Nt+1:end, :);         % -------- 计算每个车子的位置
        [addForce, rempTrains] = GetAdditionalF(mTrainGroup, pTrains, rampList);
        U = U + addForce ;                           %
        
        % ---------------------------------------------- 基本阻力
        basicForce = GetBasicF(mTrainGroup, X(1:Nt, :), C0, Ca);
        basicForce(X(1:Nt, :) <= 0) = 0;
        U = U + basicForce ;
        
        %% 更新状态方程
        
        X = Ad*X + Bd*U;
        
        %% 记录状态变量
        
        %     locF(itr, :) = tmp_Fl(1, :);
        %     airF(itr, :) = mean(currentF);
        %     addF(itr, :) = mean(addForce);
        %     basF(itr, :) = mean(basicForce);
        
        count_detaT = count_detaT+1;
        
        X_Recorder(itr, :) = X(1, :);
        
        U_recorder(:, itr) = U(:, 1);
        L_recorder(:, itr) = tmp_Fl(:, 1);
        V_recorder(:, itr) = X(1:Nt, 1);
        RP_recorder(:, itr) = rempTrains(:, 1);
        
        F_c_ = KK.*diff(X(Nt+1:Nt*2, :)) + DD.*diff(X(1:Nt, :));
%         F_c(itr, :) = sum(F_c_.^2);
        F_c(count_detaT, :) = max(abs(F_c_));
        
        F_l(count_detaT, :) = sum(tmp_Fl.^2); 
        
        errV(count_detaT, :) = sum((X(1:Nt, :) - Rspeed).^2);
        
        
        X_location(itr, :) = X(Nt+[1 Nt], 1);
        Speed_locmotive(itr, :) = X([1 Nt], 1);
        F_locmotive(itr, :) = tmp_Fl;
        N_locmotive(itr, :) = MotorNotch;
        F_coupler(itr, :) = F_c_;
        Ramp_locmotive(itr, :) = rempTrains([1 end]);
        
        %% 更新知识矩
        if rem(itr, floor(detaT/dt)) == 0   % 每 10 次 迭代做一次操作
            
            count_detaT = 0;
            
            count = count+1;
            R_tmp(1, :) = sum(F_c);
            R_tmp(2, :) = sum(F_l);
            R_tmp(3, :) = sum(F_w);
            R_tmp(4, :) = sum(errV);
            
            Rsum = Rsum + mean(R_tmp, 2);
            
            R = zeros(1, Ne);
            for atr = 1:4 
                R = R - reward_weigh(atr)*R_tmp(atr, :);
            end
            
            v_tmp_ = v_tmp;
            s_tmp_ = s_tmp;
            
            v_tmp = ceil(X(1, :)*3.6) + 1;
            s_tmp = ceil(X(Nt+1, :)/dl) + 1;
            
            Rs_record(count, :) = R;
            
            %% 选择下一步的操作 % epsilon - greedy
            
            bo_tmp = rand(1, Ne) > epsilon;
            for i = 1:Ne
                if bo_tmp(i)      % epsilon - greedy
                    [~, action(i)] = max(Q(s_tmp(i), v_tmp(i), MotorNotch(1, i)+13, MotorNotch(2, i)+13, :));
                else
                    action_tmp = find(~isnan(Q(s_tmp(i), v_tmp(i), MotorNotch(1, i)+13, MotorNotch(2, i)+13, :)));
                    action(i) = action_tmp(ceil(rand*length(action_tmp)));
                end
            end
            %%
            
            MotorNotch_ = MotorNotch;   % 保存上一次
            MotorNotch = MotorNotch + ActionSet(action, 1:2)';   % 每次变化 -1, 0 or 1.  
            
        end
        
        loc_Notchs1(itr, :) = MotorNotch(1, :);
        loc_Notchs2(itr, :) = MotorNotch(2, :); 
        
    end
    
%     Rs_record4(etr, :) = Rsum';
%     R_Recorder(etr, :) = sum(Rs_record);
end

tooc = toc;
toc

% 
%% 

xx = X_location(:, 1);
Speed_locmotive = Speed_locmotive*3.6;
% F_locmotive = F_locmotive;

%% 

hfig = figure(501);clf
set(hfig, 'position', [100, 80, 900, 890])

axes(1) = subplot(511);
hold on;
plot(xx, F_locmotive(:, 1), 'linewidth', 2);
plot(xx, F_locmotive(:, 2), 'linewidth', 2);
ylabel('牵引力 kN/m');
legend('Locmotive #1', 'Locmotive #2');
set(gca,'ylim', [-10 600]);
box on;

axes(2) = subplot(512);
hold on;
plot(xx, Speed_locmotive(:, 1), 'linewidth', 2);
plot(xx, Speed_locmotive(:, 2), 'linewidth', 2);
ylabel('速度 km/h');
set(gca,'ylim', 80+[-1 1]*10);
legend('Locmotive #1', 'Locmotive #2');
box on;

axes(3) = subplot(513);
hold on;
plot(xx, N_locmotive(:, 1), 'linewidth', 2);
plot(xx, N_locmotive(:, 2), 'linewidth', 2);
ylabel('级位 km/h');
set(gca,'ylim', [-3 13]);
legend('Locmotive #1', 'Locmotive #2');
box on;

axes(4) = subplot(514);
hold on;
plot(xx, Ramp_locmotive(:, 1), 'linewidth', 2);
plot(xx, Ramp_locmotive(:, 2), 'linewidth', 2);
ylabel('坡度');
set(gca,'ylim', [-1 1]*0.02);
legend('Locmotive #1', 'Locmotive #2');
box on;
linkaxes(axes, 'x');
set(gca,'xlim', xx([1 end]));

axes(5) = subplot(515);
hold on;
plot(xx, max(F_coupler, [], 2), 'linewidth', 2);
plot(xx, min(F_coupler, [], 2), 'linewidth', 2);
ylabel('车钩力 kN/m');
xlabel('里程 m');
% set(gca,'ylim', [-1 1]*0.02);
legend('Maximal Coupler Force', 'Maximal Coupler Force');
box on;
linkaxes(axes, 'x');
set(gca,'xlim', xx([1 end]));



% figure



























